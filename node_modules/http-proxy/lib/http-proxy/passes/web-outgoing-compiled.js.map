{"version":3,"sources":["web-outgoing.js"],"names":[],"mappings":"AAAA,IAAI,MAAS,QAAQ,KAAR,CAAb;AAAA,IACI,SAAS,OADb;;AAGA,IAAI,gBAAgB,eAApB;;AAEA;;;;;;;;AAQA,CAAE;;AAEA;;;;;;;;;AASA,SAAS,aAAT,CAAuB,GAAvB,EAA4B,GAA5B,EAAiC,QAAjC,EAA2C;AACzC,MAAI,IAAI,WAAJ,KAAoB,KAAxB,EAA+B;AAC7B,WAAO,SAAS,OAAT,CAAiB,mBAAjB,CAAP;AACD;AACF,CAfH;;AAiBE;;;;;;;;;;AAUA,SAAS,aAAT,CAAuB,GAAvB,EAA4B,GAA5B,EAAiC,QAAjC,EAA2C;AACzC,MAAI,IAAI,WAAJ,KAAoB,KAAxB,EAA+B;AAC7B,aAAS,OAAT,CAAiB,UAAjB,GAA8B,IAAI,OAAJ,CAAY,UAAZ,IAA0B,OAAxD;AACD,GAFD,MAEO,IAAI,CAAC,SAAS,OAAT,CAAiB,UAAtB,EAAkC;AACvC,aAAS,OAAT,CAAiB,UAAjB,GAA8B,IAAI,OAAJ,CAAY,UAAZ,IAA0B,YAAxD;AACD;AACF,CAjCH,EAmCE,SAAS,sBAAT,CAAgC,GAAhC,EAAqC,GAArC,EAA0C,QAA1C,EAAoD,OAApD,EAA6D;AAC3D,MAAI,CAAC,QAAQ,WAAR,IAAuB,QAAQ,WAA/B,IAA8C,QAAQ,eAAvD,KACG,SAAS,OAAT,CAAiB,UAAjB,CADH,IAEG,cAAc,IAAd,CAAmB,SAAS,UAA5B,CAFP,EAEgD;AAC9C,QAAI,SAAS,IAAI,KAAJ,CAAU,QAAQ,MAAlB,CAAb;AACA,QAAI,IAAI,IAAI,KAAJ,CAAU,SAAS,OAAT,CAAiB,UAAjB,CAAV,CAAR;;AAEA;AACA,QAAI,OAAO,IAAP,IAAe,EAAE,IAArB,EAA2B;AACzB;AACD;;AAED,QAAI,QAAQ,WAAZ,EAAyB;AACvB,QAAE,IAAF,GAAS,QAAQ,WAAjB;AACD,KAFD,MAEO,IAAI,QAAQ,WAAZ,EAAyB;AAC9B,QAAE,IAAF,GAAS,IAAI,OAAJ,CAAY,MAAZ,CAAT;AACD;AACD,QAAI,QAAQ,eAAZ,EAA6B;AAC3B,QAAE,QAAF,GAAa,QAAQ,eAArB;AACD;;AAED,aAAS,OAAT,CAAiB,UAAjB,IAA+B,EAAE,MAAF,EAA/B;AACD;AACF,CA1DH;AA2DE;;;;;;;;;;AAUA,SAAS,YAAT,CAAsB,GAAtB,EAA2B,GAA3B,EAAgC,QAAhC,EAA0C;AACxC,SAAO,IAAP,CAAY,SAAS,OAArB,EAA8B,OAA9B,CAAsC,UAAS,GAAT,EAAc;AAClD,QAAG,SAAS,OAAT,CAAiB,GAAjB,KAAyB,SAA5B,EAAsC;AACpC,UAAI,SAAJ,CAAc,OAAO,GAAP,EAAY,IAAZ,EAAd,EAAkC,SAAS,OAAT,CAAiB,GAAjB,CAAlC;AACD;AACF,GAJD;AAKD,CA3EH;;AA6EE;;;;;;;;;AASA,SAAS,eAAT,CAAyB,GAAzB,EAA8B,GAA9B,EAAmC,QAAnC,EAA6C;AAC3C,MAAI,SAAJ,CAAc,SAAS,UAAvB;AACD,CAxFH,CA0FE;AA1FF,CA2FG,OA3FH,CA2FW,UAAS,IAAT,EAAe;AACtB,SAAO,KAAK,IAAZ,IAAoB,IAApB;AACD,CA7FH","file":"web-outgoing-compiled.js","sourcesContent":["var url    = require('url'),\n    passes = exports;\n\nvar redirectRegex = /^30(1|2|7|8)$/;\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, res, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n[ // <--\n\n  /**\n   * If is a HTTP 1.0 request, remove chunk headers\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  function removeChunked(req, res, proxyRes) {\n    if (req.httpVersion === '1.0') {\n      delete proxyRes.headers['transfer-encoding'];\n    }\n  },\n\n  /**\n   * If is a HTTP 1.0 request, set the correct connection header\n   * or if connection header not present, then use `keep-alive`\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  function setConnection(req, res, proxyRes) {\n    if (req.httpVersion === '1.0') {\n      proxyRes.headers.connection = req.headers.connection || 'close';\n    } else if (!proxyRes.headers.connection) {\n      proxyRes.headers.connection = req.headers.connection || 'keep-alive';\n    }\n  },\n\n  function setRedirectHostRewrite(req, res, proxyRes, options) {\n    if ((options.hostRewrite || options.autoRewrite || options.protocolRewrite)\n        && proxyRes.headers['location']\n        && redirectRegex.test(proxyRes.statusCode)) {\n      var target = url.parse(options.target);\n      var u = url.parse(proxyRes.headers['location']);\n\n      // make sure the redirected host matches the target host before rewriting\n      if (target.host != u.host) {\n        return;\n      }\n\n      if (options.hostRewrite) {\n        u.host = options.hostRewrite;\n      } else if (options.autoRewrite) {\n        u.host = req.headers['host'];\n      }\n      if (options.protocolRewrite) {\n        u.protocol = options.protocolRewrite;\n      }\n\n      proxyRes.headers['location'] = u.format();\n    }\n  },\n  /**\n   * Copy headers from proxyResponse to response\n   * set each header in response object.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  function writeHeaders(req, res, proxyRes) {\n    Object.keys(proxyRes.headers).forEach(function(key) {\n      if(proxyRes.headers[key] != undefined){\n        res.setHeader(String(key).trim(), proxyRes.headers[key]);\n      }\n    });\n  },\n\n  /**\n   * Set the statusCode from the proxyResponse\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  function writeStatusCode(req, res, proxyRes) {\n    res.writeHead(proxyRes.statusCode);\n  }\n\n] // <--\n  .forEach(function(func) {\n    passes[func.name] = func;\n  });\n"]}