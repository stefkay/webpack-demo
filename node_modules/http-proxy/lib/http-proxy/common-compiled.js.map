{"version":3,"sources":["common.js"],"names":[],"mappings":"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","file":"common-compiled.js","sourcesContent":["var common   = exports,\n    url      = require('url'),\n    extend   = require('util')._extend,\n    required = require('requires-port');\n\nvar upgradeHeader = /(^|,)\\s*upgrade\\s*($|,)/i,\n    isSSL = /^https|wss/;\n\n/**\n * Simple Regex for testing if protocol is https\n */\ncommon.isSSL = isSSL;\n/**\n * Copies the right headers from `options` and `req` to\n * `outgoing` which is then used to fire the proxied\n * request.\n *\n * Examples:\n *\n *    common.setupOutgoing(outgoing, options, req)\n *    // => { host: ..., hostname: ...}\n *\n * @param {Object} Outgoing Base object to be filled with required properties\n * @param {Object} Options Config object passed to the proxy\n * @param {ClientRequest} Req Request Object\n * @param {String} Forward String to select forward or target\n * \n * @return {Object} Outgoing Object with all required properties set\n *\n * @api private\n */\n\ncommon.setupOutgoing = function(outgoing, options, req, forward) {\n  outgoing.port = options[forward || 'target'].port ||\n                  (isSSL.test(options[forward || 'target'].protocol) ? 443 : 80);\n\n  ['host', 'hostname', 'socketPath', 'pfx', 'key',\n    'passphrase', 'cert', 'ca', 'ciphers', 'secureProtocol'].forEach(\n    function(e) { outgoing[e] = options[forward || 'target'][e]; }\n  );\n\n  outgoing.method = req.method;\n  outgoing.headers = extend({}, req.headers);\n\n  if (options.headers){\n    extend(outgoing.headers, options.headers);\n  }\n\n  if (options.auth) {\n    outgoing.auth = options.auth;\n  }\n\n  if (isSSL.test(options[forward || 'target'].protocol)) {\n    outgoing.rejectUnauthorized = (typeof options.secure === \"undefined\") ? true : options.secure;\n  }\n\n\n  outgoing.agent = options.agent || false;\n  outgoing.localAddress = options.localAddress;\n\n  //\n  // Remark: If we are false and not upgrading, set the connection: close. This is the right thing to do\n  // as node core doesn't handle this COMPLETELY properly yet.\n  //\n  if (!outgoing.agent) {\n    outgoing.headers = outgoing.headers || {};\n    if (typeof outgoing.headers.connection !== 'string'\n        || !upgradeHeader.test(outgoing.headers.connection)\n       ) { outgoing.headers.connection = 'close'; }\n  }\n\n\n  // the final path is target path + relative path requested by user:\n  var target = options[forward || 'target'];\n  var targetPath = target && options.prependPath !== false\n    ? (target.path || '')\n    : '';\n\n  //\n  // Remark: Can we somehow not use url.parse as a perf optimization?\n  //\n  var outgoingPath = !options.toProxy\n    ? (url.parse(req.url).path || '')\n    : req.url;\n\n  //\n  // Remark: ignorePath will just straight up ignore whatever the request's\n  // path is. This can be labeled as FOOT-GUN material if you do not know what\n  // you are doing and are using conflicting options.\n  //\n  outgoingPath = !options.ignorePath ? outgoingPath : '';\n\n  outgoing.path = common.urlJoin(targetPath, outgoingPath);\n\n  if (options.changeOrigin) {\n    outgoing.headers.host =\n      required(outgoing.port, options[forward || 'target'].protocol) && !hasPort(outgoing.host)\n        ? outgoing.host + ':' + outgoing.port\n        : outgoing.host;\n  }\n  return outgoing;\n};\n\n/**\n * Set the proper configuration for sockets,\n * set no delay and set keep alive, also set\n * the timeout to 0.\n *\n * Examples:\n *\n *    common.setupSocket(socket)\n *    // => Socket\n *\n * @param {Socket} Socket instance to setup\n * \n * @return {Socket} Return the configured socket.\n *\n * @api private\n */\n\ncommon.setupSocket = function(socket) {\n  socket.setTimeout(0);\n  socket.setNoDelay(true);\n\n  socket.setKeepAlive(true, 0);\n\n  return socket;\n};\n\n/**\n * Get the port number from the host. Or guess it based on the connection type.\n *\n * @param {Request} req Incoming HTTP request.\n *\n * @return {String} The port number.\n *\n * @api private\n */\ncommon.getPort = function(req) {\n  var res = req.headers.host ? req.headers.host.match(/:(\\d+)/) : '';\n\n  return res ?\n    res[1] :\n    common.hasEncryptedConnection(req) ? '443' : '80';\n};\n\n/**\n * Check if the request has an encrypted connection.\n *\n * @param {Request} req Incoming HTTP request.\n *\n * @return {Boolean} Whether the connection is encrypted or not.\n *\n * @api private\n */\ncommon.hasEncryptedConnection = function(req) {\n  return Boolean(req.connection.encrypted || req.connection.pair);\n};\n\n/**\n * OS-agnostic join (doesn't break on URLs like path.join does on Windows)>\n *\n * @return {String} The generated path.\n *\n * @api private\n */\n\ncommon.urlJoin = function() {\n    //\n    // We do not want to mess with the query string. All we want to touch is the path.\n    //\n  var args = Array.prototype.slice.call(arguments),\n      lastIndex = args.length - 1,\n      last = args[lastIndex],\n      lastSegs = last.split('?'),\n      retSegs;\n\n  args[lastIndex] = lastSegs.shift();\n\n  //\n  // Join all strings, but remove empty strings so we don't get extra slashes from\n  // joining e.g. ['', 'am']\n  //\n  retSegs = [\n    args.filter(Boolean).join('/')\n        .replace(/\\/+/g, '/')\n        .replace('http:/', 'http://')\n        .replace('https:/', 'https://')\n  ];\n\n  // Only join the query string if it exists so we don't have trailing a '?'\n  // on every request\n\n  // Handle case where there could be multiple ? in the URL.\n  retSegs.push.apply(retSegs, lastSegs);\n\n  return retSegs.join('?')\n};\n\n/**\n * Check the host and see if it potentially has a port in it (keep it simple)\n *\n * @returns {Boolean} Whether we have one or not\n *\n * @api private\n */\nfunction hasPort(host) {\n  return !!~host.indexOf(':');\n};\n"]}