{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["'use strict';\n\nvar required = require('requires-port')\n  , lolcation = require('./lolcation')\n  , qs = require('querystringify')\n  , relativere = /^\\/(?!\\/)/\n  , protocolre = /^([a-z0-9.+-]+:)?(\\/\\/)?(.*)$/i; // actual protocol is first match\n\n/**\n * These are the parse instructions for the URL parsers, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar instructions = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/\\:(\\d+)$/, 'port'],                 // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n /**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase\n * @property {Boolean} slashes Indicates whether the protocol is followed by double slash (\"//\")\n * @property {String} rest     Rest of the URL that is not part of the protocol\n */\n\n /**\n  * Extract protocol information from a URL with/without double slash (\"//\")\n  *\n  * @param  {String} address   URL we want to extract from.\n  * @return {ProtocolExtract}  Extracted information\n  * @private\n  */\nfunction extractProtocol(address) {\n  var match = protocolre.exec(address);\n  return {\n    protocol: match[1] ? match[1].toLowerCase() : '',\n    slashes: !!match[2],\n    rest: match[3] ? match[3] : ''\n  };\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my CDO.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} location Location defaults for relative paths.\n * @param {Boolean|Function} parser Parser for the query string.\n * @api public\n */\nfunction URL(address, location, parser) {\n  if (!(this instanceof URL)) {\n    return new URL(address, location, parser);\n  }\n\n  var relative = relativere.test(address)\n    , parse, instruction, index, key\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) {\n    parser = qs.parse;\n  }\n\n  location = lolcation(location);\n\n  // extract protocol information before running the instructions\n  var extracted = extractProtocol(address);\n  url.protocol = extracted.protocol || location.protocol || '';\n  url.slashes = extracted.slashes || location.slashes;\n  address = extracted.rest;\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      if (~(index = address.indexOf(parse))) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if (index = parse.exec(address)) {\n      url[key] = index[1];\n      address = address.slice(0, address.length - index[0].length);\n    }\n\n    url[key] = url[key] || (instruction[3] || ('port' === key && relative) ? location[key] || '' : '');\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) {\n      url[key] = url[key].toLowerCase();\n    }\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n  if (url.auth) {\n    instruction = url.auth.split(':');\n    url.username = instruction[0] || '';\n    url.password = instruction[1] || '';\n  }\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} prop          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function used to parse\n *                               the query.\n *                               When setting the protocol, double slash will be removed from\n *                               the final url if it is true.\n * @returns {URL}\n * @api public\n */\nURL.prototype.set = function set(part, value, fn) {\n  var url = this;\n\n  if ('query' === part) {\n    if ('string' === typeof value && value.length) {\n      value = (fn || qs.parse)(value);\n    }\n\n    url[part] = value;\n  } else if ('port' === part) {\n    url[part] = value;\n\n    if (!required(value, url.protocol)) {\n      url.host = url.hostname;\n      url[part] = '';\n    } else if (value) {\n      url.host = url.hostname +':'+ value;\n    }\n  } else if ('hostname' === part) {\n    url[part] = value;\n\n    if (url.port) value += ':'+ url.port;\n    url.host = value;\n  } else if ('host' === part) {\n    url[part] = value;\n\n    if (/\\:\\d+/.test(value)) {\n      value = value.split(':');\n      url.hostname = value[0];\n      url.port = value[1];\n    }\n  } else if ('protocol' === part) {\n    url.protocol = value;\n    url.slashes = !fn;\n  } else {\n    url[part] = value;\n  }\n\n  url.href = url.toString();\n  return url;\n};\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String}\n * @api public\n */\nURL.prototype.toString = function toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\n  var result = protocol + (url.slashes ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  }\n\n  result += url.hostname;\n  if (url.port) result += ':'+ url.port;\n\n  result += url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n};\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others.\n//\nURL.qs = qs;\nURL.location = lolcation;\nmodule.exports = URL;\n"]}